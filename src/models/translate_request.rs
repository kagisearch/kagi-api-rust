/*
 * Kagi API
 *
 * The Kagi API provides programmatic access to data that powers our search results & more.   Quick start for all APIs:  - Create an account at [Kagi](https://kagi.com/signup) - Generate an [API key](https://kagi.com/settings?p=api) - Call the API  We have the following APIs available. ### Commercial  - Kagi Search API (invite only at the moment) - Web and News Enrichment API (public, exposes Kagi's own indexes Teclis and TinyGem) - Universal Summarizer API (public) - FastGPT API (public)  ### Free  - Kagi Small Web RSS feed (public)  ### Official Client Libraries  We offer the following libraries you can use to interact with the Kagi API. These are generated from an OpenAPI spec. If you have a language you would like to use and it's not in the list, send us a message and we will add it to the list if it is supported. Or you can use the [spec](https://wild-wombat.redocly.app/_spec/openapi.yaml?download) to build your own custom library.  - [Golang](https://github.com/kagisearch/kagi-api-golang) - [Python](https://github.com/kagisearch/kagi-api-python)  ### Unofficial Client Libraries  There also exist third party libraries for interacting with the Kagi API.  - [kagigo for Go](https://github.com/httpjamesm/kagigo) - FastGPT & Universal Summarizer - [kagi-api](https://crates.io/crates/kagi-api) for Rust - [kagi-api](https://alchemists.io/projects/kagi-api) for Ruby - [kagi-dotnet](https://github.com/patchoulish/kagi-dotnet) for C#/.NET  ### API Status  Our existing API, the \"v0\" beta API, is being replaced with a new version that will be available publicly soon. As changes are made, we will be updating the documentation below when the new features become available.  See the [Support and Community](https://help.kagi.com/kagi/support-and-community/) section for details. ### Pricing  We are in the process of moving all APIs to a post-paid tiered system, where each tier has a limit on the number of requests that can be made. If an API has a pricing section, then it is still being migrated over to the new billing system.  ### GitHub Discussions  This is the preferred venue for bug reports and feature requests.  - [Bug Reports](https://github.com/kagisearch/kagi-docs/issues/new/choose) - [Q&A Forum](https://github.com/kagisearch/kagi-docs/discussions/categories/q-a?discussions_q=category%3AQ%26A+label%3Aproduct%3Akagi_search_api) - [API Feature Requests](https://github.com/kagisearch/kagi-docs/discussions/categories/kagi-search-api-feature-requests-ideas)  ### Discord Join our [Discord](https://kagi.com/discord)! Good for quick questions or chatting about things you've made with our APIs! 
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: support@kagi.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct TranslateRequest {
    #[serde(rename = "text")]
    pub text: Box<models::TranslateRequestText>,
    /// Source language code (ISO-639) or \"auto\" for automatic detection
    #[serde(rename = "source_lang", skip_serializing_if = "Option::is_none")]
    pub source_lang: Option<String>,
    /// Target language code (ISO-639)
    #[serde(rename = "target_lang", skip_serializing_if = "Option::is_none")]
    pub target_lang: Option<String>,
    /// Legacy parameter for source language (use source_lang instead)
    #[serde(rename = "from", skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Legacy parameter for target language (use target_lang instead)
    #[serde(rename = "to", skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
    /// Additional context to improve translation accuracy
    #[serde(rename = "context", skip_serializing_if = "Option::is_none")]
    pub context: Option<String>,
    /// Whether to preserve original text formatting
    #[serde(rename = "preserve_formatting", skip_serializing_if = "Option::is_none")]
    pub preserve_formatting: Option<bool>,
    /// Level of formality in translation. All formality levels are supported for all language pairs. 'prefer_more' is same as 'more', and 'prefer_less' is same as 'less' (included for backwards compatibility).
    #[serde(rename = "formality", skip_serializing_if = "Option::is_none")]
    pub formality: Option<Formality>,
    /// Gender of the speaker for languages with gender-specific expressions
    #[serde(rename = "speaker_gender", skip_serializing_if = "Option::is_none")]
    pub speaker_gender: Option<SpeakerGender>,
    /// Gender of the addressee for languages with gender-specific expressions
    #[serde(rename = "addressee_gender", skip_serializing_if = "Option::is_none")]
    pub addressee_gender: Option<AddresseeGender>,
    /// Style of translation (natural for fluency, literal for exactness)
    #[serde(rename = "translation_style", skip_serializing_if = "Option::is_none")]
    pub translation_style: Option<TranslationStyle>,
    /// Pre-detected source language (if available)
    #[serde(rename = "predicted_language", skip_serializing_if = "Option::is_none")]
    pub predicted_language: Option<String>,
    /// Pre-generated translation (if available)
    #[serde(rename = "prediction", skip_serializing_if = "Option::is_none")]
    pub prediction: Option<String>,
    /// Whether to stream the response as Server-Sent Events
    #[serde(rename = "stream", skip_serializing_if = "Option::is_none")]
    pub stream: Option<bool>,
    /// Language code for dictionary definitions (if not provided, the source language will be used)
    #[serde(rename = "dictionary_language", skip_serializing_if = "Option::is_none")]
    pub dictionary_language: Option<String>,
}

impl TranslateRequest {
    pub fn new(text: models::TranslateRequestText) -> TranslateRequest {
        TranslateRequest {
            text: Box::new(text),
            source_lang: None,
            target_lang: None,
            from: None,
            to: None,
            context: None,
            preserve_formatting: None,
            formality: None,
            speaker_gender: None,
            addressee_gender: None,
            translation_style: None,
            predicted_language: None,
            prediction: None,
            stream: None,
            dictionary_language: None,
        }
    }
}
/// Level of formality in translation. All formality levels are supported for all language pairs. 'prefer_more' is same as 'more', and 'prefer_less' is same as 'less' (included for backwards compatibility).
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Formality {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "more")]
    More,
    #[serde(rename = "less")]
    Less,
    #[serde(rename = "prefer_more")]
    PreferMore,
    #[serde(rename = "prefer_less")]
    PreferLess,
}

impl Default for Formality {
    fn default() -> Formality {
        Self::Default
    }
}
/// Gender of the speaker for languages with gender-specific expressions
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum SpeakerGender {
    #[serde(rename = "unknown")]
    Unknown,
    #[serde(rename = "feminine")]
    Feminine,
    #[serde(rename = "masculine")]
    Masculine,
    #[serde(rename = "neutral")]
    Neutral,
}

impl Default for SpeakerGender {
    fn default() -> SpeakerGender {
        Self::Unknown
    }
}
/// Gender of the addressee for languages with gender-specific expressions
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum AddresseeGender {
    #[serde(rename = "unknown")]
    Unknown,
    #[serde(rename = "feminine")]
    Feminine,
    #[serde(rename = "masculine")]
    Masculine,
    #[serde(rename = "neutral")]
    Neutral,
}

impl Default for AddresseeGender {
    fn default() -> AddresseeGender {
        Self::Unknown
    }
}
/// Style of translation (natural for fluency, literal for exactness)
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum TranslationStyle {
    #[serde(rename = "natural")]
    Natural,
    #[serde(rename = "literal")]
    Literal,
}

impl Default for TranslationStyle {
    fn default() -> TranslationStyle {
        Self::Natural
    }
}

